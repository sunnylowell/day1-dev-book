## item12: 함수 표현식에 타입 적용하기
javascript 와 typescript 에서는 함수문장 과 함수표현식을 다르게 인식한다. 
장점
- 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 사용할 수 있기 때문에, 함수 표현식을 사용하는 것이 좋다.
- 반복코드를 줄인다. (예를 들면, 다른 동작을 하지만 리턴타입과 매개변수의 타입이 동일한 여러개의 함수가 있을 때)
- 다른 함수의 시그니처를 사용하기 위해서는 typeof fn 을 사용하면 된다.


## item13: 타입과 인터페이스의 차이 알기
- 공통점
  - 두 방법으로 정의하는 것은 상태에 차이가 없다.
  - 둘다 함수타입을 정의할 수 있다.
  - 인터페이스는 타입을 확장할 수 있고, 타입은 인터페이스를 확장할 수 있다.
  - 클래스 구현(implements) 시에도 타입과 인터페이스 둘다 사용할 수 있다

- 차이점
  - 인터페이스는 유니온 타입 같은 복잡한 타입을 확장하지 못한다. 복잡한 타입을 확장하고 싶다면 & 를 사용해야한다. 유니온 타입은 있지만 유니온 인터페이스는 없다.
  

- 경우에 따른 사용 결정 ( 타입 vs 인터페이스 )
  - 복잡한 타입이라면 타입별칭(type)을 사용한다.
  - 두가지 모두 사용할 수 있다면, 일관성과 보강의 관점에서 생각해보기

## item14: 타입 연산과 제너릭 사용으로 반복 줄이기



## 기억할 것
- 자주 사용하던 [key:string]: string 과 같은 형식을 '인덱스 시그니처'라 한다. 아래 example 참고
```
type TDict = {[key: string]: string};
```
- 병합: 예를들면, es5 -> es6 로 버전이 올라가면서 es6의 새로운 선언들이 인터페이스에 추가된다. 병합은 일반적인 코드라서 언제든지 가능하다.
- DRY 원칙: Don't Repeat Yourself (같은 코드를 반복하지 말라).


## 질문
77p. 유니온 타입은 확장할 수가 없나?